from methpy.__init__ import Table_info, find_all
import numpy as np
import os
import openpyxl
import operator
import pandas as pd
from pathlib import Path
import sys
import xlsxwriter
import xlwings as xw

def table ():
    """Generates a table file from the txt files output generated by the check function"""
    script_path = os.getcwd ()
    table_path = os.path.join (script_path, "Tables")

    #gets info
    informations = Table_info ().response
    try:
        name_reference = informations ["gene name"]
        condition_path = informations ["condition path"] 
        if informations ["start position"] != "":
            real_number = informations ["start position"]
        else: real_number = 1

        #opens the references
        path_forward = os.path.join (script_path, "References" , name_reference + "F.txt")
        reference = open (path_forward, "r")
        reference = reference.read ()

        #creates a list that starts with "Colony's name" and "Strand" and has the positions of all the Cs in the sequence
        index_c = ["Colony's name", "Strand"] 
        for position in range (len(reference)):
            if reference[position] == "C":
                index_c.append (position + 1)

        #creates a dataframe with the list described above as the columns names
        df = pd.DataFrame (columns= index_c)

        #creates a row with the Cs positions taking into account from which nucleotide the sequence starts
        real_indeces = [" ", " "]
        for i in index_c [2:]:
            real_indeces.append (int(i)+int(real_number)-1)

        real_indeces_df = pd.DataFrame ([real_indeces], columns = df.columns.tolist())
        df = pd.concat([df, real_indeces_df])
        
        #takes all the file in the folder selected
        for file_name in Path(condition_path).iterdir ():
            #reads every txt
            with open (file_name, "r") as sequence:
                sequence = sequence.read ()
                divided_sequence = sequence.split ("\n")
                #takes the Cs methylated from the second row until the doubtful_c_positions
                list_c_methylated = divided_sequence [1:divided_sequence.index ("doubtful_c_positions")]

                #if that list is not empty, creates a list of Cs methylated
                if list_c_methylated [-1] != "":
                    list_c_methylated = list (map (int, list_c_methylated))

                #from doubtful_c_positions until the penultimate number are the "doubtful" Cs
                list_c_doubtful = divided_sequence [divided_sequence.index("doubtful_c_positions")+1:-2]

                #creates a list of doubtful Cs
                if list_c_doubtful [-1] != "":
                    list_c_doubtful = list (map (int, list_c_doubtful))
                    
                #the first row of the txt file is the sequence name
                sequence_name = divided_sequence [0]
                name_without_strand = sequence_name [:-1]

                #the last row is the strand
                strand_type = divided_sequence [-1]

                #if it is a forward
                if divided_sequence [-1] == "F":
                    #it creates a list with 0 when not mwthylated, 1 when methylated and 2 when the Cs are "doubtful"
                    list_excel = [
                    1 if x in list_c_methylated else 0 + 2 * (x > int (divided_sequence[-2]))
                    for x in index_c [2:]
                ]
                    list_doubtful_excel = [2 if x in list_c_doubtful else 0 for x in index_c[2:]]

                #if it is a forward
                elif divided_sequence [-1] == "R":
                    #it creates a list with 0 when not mwthylated, 1 when methylated and 2 when the Cs are "doubtful"
                    list_excel = [
                    1 if x in list_c_methylated else 0 + 2 * (x < int (divided_sequence[-2]))
                    for x in index_c[2:]
                ]
                    list_doubtful_excel = [2 if x in list_c_doubtful else 0 for x in index_c[2:]]
                
                final_with_doubtful = list (map(operator.add, list_excel, list_doubtful_excel))
                #adds also the name and strand type and creates with it a new row into the dataframe
                final_row = [name_without_strand] + [strand_type] + final_with_doubtful
                row_df = pd.DataFrame ([final_row],columns = df.columns.tolist())
                df = pd.concat([df, row_df])

        real_c_position = pd.DataFrame([df.iloc [0]], columns = df.columns.tolist ())
        df = df[1:]
        pd.set_option('future.no_silent_downcasting', True)
        df = df.replace(0, "No Methylated")
        df = df.replace(1, "Methylated")
        df = df.replace(2, "No Data")
        df = pd.concat ([real_c_position, df])

        #takes the "colonies" names, that are the sequences name
        colonies_names = df ["Colony's name"]
        colonies_names_noblank = colonies_names [1:]
        colonies_no_duplicates = pd.DataFrame (colonies_names_noblank.drop_duplicates())
        colonies_no_duplicates ["Strand"] = "F-R"
        df = pd.concat ([df, colonies_no_duplicates])

        #sorts first by name and then by strand
        df_index_order = {"F": 0, "R":1, "F-R":2}
        df = df.sort_values (["Strand"], key = pd.Series (df_index_order).reindex)
        df.reset_index (inplace = True, drop = True)
        df ['index'] = df.index
        df = df.sort_values (["Colony's name", "index"], ascending = True) 
        df = df.drop (["index"], axis = 1)
        df.reset_index (inplace = True, drop = True)

        #creates a list of F-R indeces
        F_R_indeces = df [df["Strand"] == "F-R"].index.tolist ()
        F_R_differences = (pd.Series ([0]+(F_R_indeces)).diff ()).tolist ()
        F_R_differences = F_R_differences [1:]
        #creates a dictionary, as keys possible strands combinations, as values the result of that combinations
        FR_to_F_R_dict = {
            "MethylatedMethylated" : "Methylated",
            "MethylatedNo Data" : "Methylated",
            "No DataMethylated" : "Methylated",
            "MethylatedNo Methylated" : "Hemi Methylated",
            "No MethylatedMethylated" : "Hemi Methylated",
            "No MethylatedNo Methylated" : "No Methylated",
            "No DataNo Methylated" : "No Methylated",
            "No MethylatedNo Data" : "No Methylated",
            "No DataNo Data" : "No Data",
        }

        hide_rows = []
        for number in range (len (F_R_differences)):
            index_FR_merged =  F_R_indeces [number]

            #if the difference between two F-R is 2 not both strands were analyzed
            #the F-R row will take the value of the single strand analyzed 
            if F_R_differences [number] == 2:
                index_single_strand = F_R_indeces [number] -1
                for name in df.columns [2:]:
                    cell_value = str (df.loc [index_single_strand, name])

                    if cell_value == "Methylated": 
                        df.loc [index_FR_merged, name] = "Methylated"
                    elif cell_value == "No Methylated":
                        df.loc [index_FR_merged, name] = "No Methylated"
                    elif cell_value == "No Data":
                        df.loc [index_FR_merged, name] = "No Data"

                hide_rows.append (index_single_strand) 
              
            elif F_R_differences [number] == 3:
                index_F = F_R_indeces [number] -2
                index_R = F_R_indeces [number] -1

                #does the merge between F and R
                for name in df.columns [2:]:
                    cell_valueF = str (df.loc [index_F, name])
                    cell_valueR = str (df.loc [index_R, name])
                    total_value = cell_valueF + cell_valueR
                    df.loc [index_FR_merged, name] = FR_to_F_R_dict [total_value]

                hide_rows.append (index_F)
                hide_rows.append (index_R)

        #search for "CpG" or "CCTCC" into the reference
        cpg_list = find_all (reference, "CG")[1]
        cctcc_list = find_all (reference, "CCTCC")[1]
        condition_folder = condition_path.split ("Output in txt") [1]

        condition_name = condition_folder.replace ( "/", "_")
        #adds to the dataframe where there are CpGs
        cpg_row = ["", ""]
        for i in df.loc[2][2:].index:
            if i in cpg_list:
                cpg_row.append ("CpG")
            else: cpg_row.append (0)
        df_csv = df.copy (deep = True)
        df_csv.loc["CpG Presence"] = cpg_row
        df_csv = df_csv.iloc[np.arange(-1, len(df_csv)-1)]
        
        #calculates the percentage of methylation for each Cs
        df_FR = df.loc[F_R_indeces]
        methylated = df_FR.isin(["Methylated"]).sum()
        no_data = df_FR.isin(["No Data"]).sum()
        sum_without_nodata = abs(no_data.sub (len(df_FR)))
        percentage = methylated.div (sum_without_nodata).mul (100)
        percentage = percentage.astype(object)
        percentage ["Colony's name"] = ""
        percentage ["Strand"] = ""
        df_csv.loc ["Percentage"] = percentage

        #creates the csv
        path_csv = os.path.join (table_path, f"Methylation_{name_reference}_{condition_name}.csv")
        df_csv.to_csv (path_csv, sep = ";", na_rep='NULL')
        print ("Plotted into a csv all the controlled sequences of", condition_name[1:])
        if informations ["xlsx file"] == 1:
            #creates name and file for excel
            path_excel = os.path.join (table_path, f"Methylation_{name_reference}_{condition_name}.xlsx")
            wb_to_update =  xw.Book ()
            sheet_to_write = wb_to_update.sheets [0]

            #writes the legend in excel
            sheet_to_write ["A1"].value = "Methylated"
            sheet_to_write ["A1"].font.color = "#FFFFFF"
            sheet_to_write ["A1"].color = "#000000"
            sheet_to_write ["A2"].value = "Hemi Methylated"
            sheet_to_write ["A2"].color = "#BFBFBF"
            sheet_to_write ["A3"].value = "No Methylated"
            sheet_to_write ["A4"].value = "No Data"
            sheet_to_write ["A4"].color = "#B4C6E7"
            sheet_to_write ["B1"].value = "CpG"
            sheet_to_write ["B1"].font.color = "#FF0000"
            sheet_to_write ["B2"].value = "CCTCC"
            sheet_to_write ["B2"].font.color = "#00B050"
            #adds the dataframe into excel
            sheet_to_write ["C3"].value = df.set_index ("Colony's name")
            sheet_to_write.range ("A1").column_width = 15
            sheet_to_write.range ("B1").column_width = 15     
            sheet_to_write.range ("C1").column_width = 15

            #changes the color of every cell
            for everycell in sheet_to_write.range ((5, 5), (len(df.index)+3, (len(df.columns)+2))): #len(df. index)non tiene conto della riga con i nomi colonna
                everycell.font.size = 6
                if everycell.value == "Methylated": 
                    everycell.color = "#000000"
                elif everycell.value == "No Methylated":
                    everycell.font.color = "#FFFFFF"
                elif everycell.value == "No Data":
                    everycell.color = "#B4C6E7"
                    everycell.font.color = "#B4C6E7"
                elif everycell.value == "Hemi Methylated":
                    everycell.font.color = "#BFBFBF"
                    everycell.color = "#BFBFBF"           
            
            for column_number in range (4, (len(df.columns)+2)):
                column_letter = xlsxwriter.utility.xl_col_to_name (column_number) 

                #CpG in red
                for cpg in cpg_list:
                    if sheet_to_write [f"{column_letter}3"].value == cpg:
                        sheet_to_write [f"{column_letter}3"].font.color = "#FF0000"
                        sheet_to_write [f"{column_letter}4"].font.color = "#FF0000"

                #CCTCC in green            
                for cctcc in cctcc_list:
                    if sheet_to_write [f"{column_letter}3"].value == cctcc:
                        for all_c in [0, 1, 2, 3]:
                            column_letter = xlsxwriter.utility.xl_col_to_name (column_number+all_c)
                            sheet_to_write [f"{column_letter}3"].font.color = "#00B050"
                            sheet_to_write [f"{column_letter}4"].font.color = "#00B050"

            FR_row_excel = []

            #takes where and how many are the rows with F-R
            for i in F_R_indeces:
                FR_row_excel.append (i+4)

            #adds the formula to calculate the percentage of colonies methylated
            for column in range (4, (len(df.columns)+2)): 
                FR_methylated = ""
                FR_hemimethylated = ""
                number_colonies = ""
                formula_row = FR_row_excel [-1] + 2
                column_letter = xlsxwriter.utility.xl_col_to_name (column) 
                for i in FR_row_excel:
                    if FR_methylated != "":
                        FR_methylated = FR_methylated + "+"
                        FR_hemimethylated = FR_hemimethylated + "+"
                        number_colonies = number_colonies + "+"

                    FR_methylated = FR_methylated + f'COUNTIF({column_letter}{i},"Methylated")' 
                    FR_hemimethylated = FR_hemimethylated + f'COUNTIF({column_letter}{i},"Hemi Methylated")'
                    number_colonies = number_colonies + f'COUNTIF({column_letter}{i}, "<>No Data")'
                       
                formula = f"=SUM({FR_methylated}+({FR_hemimethylated})/2)"
                sheet_to_write [f"{column_letter}{formula_row}"].formula = formula
                sheet_to_write [f"{column_letter}{formula_row + 1}"].formula = f"=({column_letter}{formula_row})/({number_colonies})"

            try:
                #saves and closes the excel file
                wb_to_update.save (path_excel)
                wb_to_update.close ()

                wb_to_update = openpyxl.load_workbook (path_excel)
                sheet = wb_to_update.active

                #hides the rows in which there are single strands
                for i in hide_rows:
                    sheet.row_dimensions [i+4].hidden = True
                wb_to_update.save (path_excel)

                #this is because otherwise openpyxl reads the results of excel formulas as None
                excel_app = xw.App (visible = False)    
                wb = excel_app.books.open (path_excel)
                wb.save ()
                wb.close ()
                excel_app.quit ()
            
                print ("Plotted into excel all the controlled sequences of", condition_name[1:])

            except: print ("Failed to save the Excel file.")

    except:
        print ("Insert valid info.")

sys.modules[__name__] = table